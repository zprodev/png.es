function calcAdler32(e){let t=1,n=0;const r=e.length;for(let i=0;i<r;i++)n=((t=(t+e[i])%65521)+n)%65521;return(n<<16)+t}const BTYPE=Object.freeze({UNCOMPRESSED:0,FIXED:1,DYNAMIC:2}),BLOCK_MAX_BUFFER_LEN=131072,LENGTH_EXTRA_BIT_LEN=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],LENGTH_EXTRA_BIT_BASE=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258],DISTANCE_EXTRA_BIT_BASE=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577],DISTANCE_EXTRA_BIT_LEN=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],CODELEN_VALUES=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];function generateHuffmanTable(e){const t=Object.keys(e);let n=0,r=0,i=Number.MAX_SAFE_INTEGER;t.forEach(e=>{n=Number(e),r<n&&(r=n),i>n&&(i=n)});let a,o=0;const s={};for(let t=i;t<=r;t++){void 0===(a=e[t])&&(a=[]),a.sort((e,t)=>e<t?-1:e>t?1:0);const n={};a.forEach(e=>{n[o]=e,o++}),s[t]=n,o<<=1}return s}function makeFixedHuffmanCodelenValues(){const e={7:[],8:[],9:[]};for(let t=0;t<=287;t++)t<=143?e[8].push(t):t<=255?e[9].push(t):t<=279?e[7].push(t):e[8].push(t);return e}function generateDeflateHuffmanTable(e,t=15){const n={};for(const t of e)n[t]?n[t]++:n[t]=1;const r=Object.keys(n);let i=[],a=0,o=[];if(1===r.length)o.push({count:n[0],simbles:[Number(r[0])]});else for(let e=0;e<t;e++){for(o=[],r.forEach(e=>{const t={count:n[Number(e)],simbles:[Number(e)]};o.push(t)}),a=0;a+2<=i.length;){const e={count:i[a].count+i[a+1].count,simbles:i[a].simbles.concat(i[a+1].simbles)};o.push(e),a+=2}(o=o.sort((e,t)=>e.count<t.count?-1:e.count>t.count?1:0)).length%2!=0&&o.pop(),i=o}const s={};let l;o.forEach(e=>{e.simbles.forEach(e=>{s[e]?s[e]++:s[e]=1})});const f=Object.keys(s),E={};let c=0,h=3,d=Number.MAX_SAFE_INTEGER,u=0;f.forEach(e=>{h=s[Number(e)],E[h]||(E[h]=[],d>h&&(d=h),u<h&&(u=h)),E[h].push(Number(e))}),c=0;const _=new Map;for(let e=d;e<=u;e++)(l=E[e])&&(l=l.sort((e,t)=>e<t?-1:e>t?1:0)).forEach(t=>{_.set(t,{code:c,bitlen:e}),c++}),c<<=1;return _}const REPEAT_LEN_MIN=3,FAST_INDEX_CHECK_MAX=128,FAST_INDEX_CHECK_MIN=16,FAST_REPEAT_LENGTH=8;function generateLZ77IndexMap(e,t,n){const r=t+n-REPEAT_LEN_MIN,i={};for(let n=t;n<=r;n++){const t=e[n]<<16|e[n+1]<<8|e[n+2];void 0===i[t]&&(i[t]=[]),i[t].push(n)}return i}function generateLZ77Codes(e,t,n){let r=t;const i=t+n-REPEAT_LEN_MIN;let a=0,o=0,s=0,l=0,f=0,E=0,c=0;const h=[],d={},u={},_=generateLZ77IndexMap(e,t,n);for(;r<=i;){const t=e[r]<<16|e[r+1]<<8|e[r+2],n=_[t];if(void 0===n||n.length<=1){h.push([e[r]]),r++;continue}a=r>32768?r-32768:0,s=0,l=0;let T=d[t]||0;for(;n[T]<a;)T=T+1|0;for(d[t]=T,T=u[t]||0;n[T]<r;)T=T+1|0;u[t]=T;let w=0;e:for(let i=u[t]-1,a=d[t];a<=i&&!(w>=FAST_INDEX_CHECK_MAX||s>=FAST_REPEAT_LENGTH&&w>=FAST_INDEX_CHECK_MIN);i--){w++;const t=n[i];for(let n=s-1;0<n;n--)if(e[t+n]!==e[r+n])continue e;o=258;for(let n=s;n<=258;n++)if(e[t+n]!==e[r+n]){o=n;break}if(s<o&&(s=o,l=t,258<=o))break}if(s>=3&&r+s<=i){f=r-l;for(let e=0;e<LENGTH_EXTRA_BIT_BASE.length&&!(LENGTH_EXTRA_BIT_BASE[e]>s);e++)E=e;for(let e=0;e<DISTANCE_EXTRA_BIT_BASE.length&&!(DISTANCE_EXTRA_BIT_BASE[e]>f);e++)c=e;h.push([E,c,s,f]),r+=s}else h.push([e[r]]),r++}return h.push([e[r]]),h.push([e[r+1]]),h}class BitWriteStream{constructor(e,t=0,n=0){this.nowBitsIndex=0,this.isEnd=!1,this.buffer=e,this.bufferIndex=t,this.nowBits=e[t],this.nowBitsIndex=n}write(e){if(this.isEnd)throw new Error("Lack of data length");e<<=this.nowBitsIndex,this.nowBits+=e,this.nowBitsIndex++,this.nowBitsIndex>=8&&(this.buffer[this.bufferIndex]=this.nowBits,this.bufferIndex++,this.nowBits=0,this.nowBitsIndex=0,this.buffer.length<=this.bufferIndex&&(this.isEnd=!0))}writeRange(e,t){let n=1,r=0;for(let i=0;i<t;i++)r=e&n?1:0,this.write(r),n<<=1}writeRangeCoded(e,t){let n=1<<t-1,r=0;for(let i=0;i<t;i++)r=e&n?1:0,this.write(r),n>>>=1}}function deflate(e){const t=e.length,n=new BitWriteStream(new Uint8Array(t<BLOCK_MAX_BUFFER_LEN/2?BLOCK_MAX_BUFFER_LEN:2*t));let r=0,i=0;for(;r+BLOCK_MAX_BUFFER_LEN>=t?(i=t-r,n.writeRange(1,1)):(i=BLOCK_MAX_BUFFER_LEN,n.writeRange(0,1)),n.writeRange(BTYPE.DYNAMIC,2),deflateDynamicBlock(n,e,r,i),!((r+=BLOCK_MAX_BUFFER_LEN)>=t););return 0!==n.nowBitsIndex&&n.writeRange(0,8-n.nowBitsIndex),n.buffer.subarray(0,n.bufferIndex)}function deflateDynamicBlock(e,t,n,r){const i=generateLZ77Codes(t,n,r),a=[256],o=[];let s=256,l=0;for(let e=0,t=i.length;e<t;e++){const t=i[e];let n=t[0];const r=t[1];void 0!==r&&(n+=257,o.push(r),l<r&&(l=r)),a.push(n),s<n&&(s=n)}const f=generateDeflateHuffmanTable(a),E=generateDeflateHuffmanTable(o),c=[];for(let e=0;e<=s;e++)f.has(e)?c.push(f.get(e).bitlen):c.push(0);const h=c.length;for(let e=0;e<=l;e++)E.has(e)?c.push(E.get(e).bitlen):c.push(0);const d=c.length-h,u=[],_=[];let T=0,w=0;for(let e=0;e<c.length;e++){for(T=c[e],w=1;T===c[e+1];)if(w++,e++,0===T){if(138<=w)break}else if(6<=w)break;if(4<=w)0===T?11<=w?u.push(18):u.push(17):(u.push(T),_.push(1),w--,u.push(16)),_.push(w);else for(let e=0;e<w;e++)u.push(T),_.push(1)}const g=generateDeflateHuffmanTable(u,7);let R,A=0;CODELEN_VALUES.forEach((e,t)=>{g.has(e)&&(A=t+1)}),e.writeRange(h-257,5),e.writeRange(d-1,5),e.writeRange(A-4,4);for(let t=0;t<A;t++)void 0!==(R=g.get(CODELEN_VALUES[t]))?e.writeRange(R.bitlen,3):e.writeRange(0,3);u.forEach((t,n)=>{if(void 0===(R=g.get(t)))throw new Error("Data is corrupted");e.writeRangeCoded(R.code,R.bitlen),18===t?e.writeRange(_[n]-11,7):17===t?e.writeRange(_[n]-3,3):16===t&&e.writeRange(_[n]-3,2)});for(let t=0,n=i.length;t<n;t++){const n=i[t],r=n[0],a=n[1];if(void 0!==a){if(void 0===(R=f.get(r+257)))throw new Error("Data is corrupted");e.writeRangeCoded(R.code,R.bitlen),0<LENGTH_EXTRA_BIT_LEN[r]&&(w=n[2],e.writeRange(w-LENGTH_EXTRA_BIT_BASE[r],LENGTH_EXTRA_BIT_LEN[r]));const t=E.get(a);if(void 0===t)throw new Error("Data is corrupted");if(e.writeRangeCoded(t.code,t.bitlen),0<DISTANCE_EXTRA_BIT_LEN[a]){const t=n[3];e.writeRange(t-DISTANCE_EXTRA_BIT_BASE[a],DISTANCE_EXTRA_BIT_LEN[a])}}else{if(void 0===(R=f.get(r)))throw new Error("Data is corrupted");e.writeRangeCoded(R.code,R.bitlen)}}if(void 0===(R=f.get(256)))throw new Error("Data is corrupted");e.writeRangeCoded(R.code,R.bitlen)}class BitReadStream{constructor(e,t=0){this.nowBitsLength=0,this.isEnd=!1,this.buffer=e,this.bufferIndex=t,this.nowBits=e[t],this.nowBitsLength=8}read(){if(this.isEnd)throw new Error("Lack of data length");const e=1&this.nowBits;return this.nowBitsLength>1?(this.nowBitsLength--,this.nowBits>>=1):(this.bufferIndex++,this.bufferIndex<this.buffer.length?(this.nowBits=this.buffer[this.bufferIndex],this.nowBitsLength=8):(this.nowBitsLength=0,this.isEnd=!0)),e}readRange(e){for(;this.nowBitsLength<=e;)this.nowBits|=this.buffer[++this.bufferIndex]<<this.nowBitsLength,this.nowBitsLength+=8;const t=this.nowBits&(1<<e)-1;return this.nowBits>>>=e,this.nowBitsLength-=e,t}readRangeCoded(e){let t=0;for(let n=0;n<e;n++)t<<=1,t|=this.read();return t}}class Uint8WriteStream{constructor(e){this.index=0,this.buffer=new Uint8Array(e),this.length=e,this._extendedSize=e}write(e){if(this.length<=this.index){this.length+=this._extendedSize;const e=new Uint8Array(this.length),t=this.buffer.length;for(let n=0;n<t;n++)e[n]=this.buffer[n];this.buffer=e}this.buffer[this.index]=e,this.index++}}const FIXED_HUFFMAN_TABLE=generateHuffmanTable(makeFixedHuffmanCodelenValues());function inflate(e,t=0){const n=new Uint8WriteStream(10*e.length),r=new BitReadStream(e,t);let i=0,a=0;for(;1!==i;){if(i=r.readRange(1),(a=r.readRange(2))===BTYPE.UNCOMPRESSED)inflateUncompressedBlock(r,n);else if(a===BTYPE.FIXED)inflateFixedBlock(r,n);else{if(a!==BTYPE.DYNAMIC)throw new Error("Not supported BTYPE : "+a);inflateDynamicBlock(r,n)}if(0===i&&r.isEnd)throw new Error("Data length is insufficient")}return n.buffer.subarray(0,n.index)}function inflateUncompressedBlock(e,t){e.nowBitsLength<8&&e.readRange(e.nowBitsLength);const n=e.readRange(8)|e.readRange(8)<<8;if(n+(e.readRange(8)|e.readRange(8)<<8)!==65535)throw new Error("Data is corrupted");for(let r=0;r<n;r++)t.write(e.readRange(8))}function inflateFixedBlock(e,t){const n=FIXED_HUFFMAN_TABLE,r=Object.keys(n);let i=0,a=0,o=Number.MAX_SAFE_INTEGER;r.forEach(e=>{i=Number(e),a<i&&(a=i),o>i&&(o=i)});let s,l,f,E,c,h,d,u,_=0;for(;!e.isEnd;){for(s=void 0,i=o,_=e.readRangeCoded(o);void 0===(s=n[i][_]);){if(a<=i)throw new Error("Data is corrupted");i++,_<<=1,_|=e.read()}if(s<256)t.write(s);else{if(256===s)break;f=LENGTH_EXTRA_BIT_BASE[l=s-257],0<(E=LENGTH_EXTRA_BIT_LEN[l])&&(f+=e.readRange(E)),c=e.readRangeCoded(5),h=DISTANCE_EXTRA_BIT_BASE[c],0<(d=DISTANCE_EXTRA_BIT_LEN[c])&&(h+=e.readRange(d)),u=t.index-h;for(let e=0;e<f;e++)t.write(t.buffer[u+e])}}}function inflateDynamicBlock(e,t){const n=e.readRange(5)+257,r=e.readRange(5)+1,i=e.readRange(4)+4;let a=0;const o={};for(let t=0;t<i;t++)0!==(a=e.readRange(3))&&(o[a]||(o[a]=[]),o[a].push(CODELEN_VALUES[t]));const s=generateHuffmanTable(o),l=Object.keys(s);let f=0,E=Number.MAX_SAFE_INTEGER;l.forEach(e=>{a=Number(e),f<a&&(f=a),E>a&&(E=a)});const c={},h={};let d,u=0,_=0,T=0;const w=n+r;for(let t=0;t<w;){for(d=void 0,a=E,u=e.readRangeCoded(E);void 0===(d=s[a][u]);){if(f<=a)throw new Error("Data is corrupted");a++,u<<=1,u|=e.read()}if(16===d?_=3+e.readRange(2):17===d?(_=3+e.readRange(3),T=0):18===d?(_=11+e.readRange(7),T=0):(_=1,T=d),T<=0)t+=_;else for(;_;)t<n?(c[T]||(c[T]=[]),c[T].push(t++)):(h[T]||(h[T]=[]),h[T].push(t++-n)),_--}const g=generateHuffmanTable(c),R=generateHuffmanTable(h),A=Object.keys(g);let B=0,I=0,N=Number.MAX_SAFE_INTEGER;A.forEach(e=>{B=Number(e),I<B&&(I=B),N>B&&(N=B)});const p=Object.keys(R);let L=0,b=0,P=Number.MAX_SAFE_INTEGER;p.forEach(e=>{L=Number(e),b<L&&(b=L),P>L&&(P=L)});let C,D,U,S,m,x,y,F,O,X,G=0;for(;!e.isEnd;){for(C=void 0,B=N,G=e.readRangeCoded(N);void 0===(C=g[B][G]);){if(I<=B)throw new Error("Data is corrupted");B++,G<<=1,G|=e.read()}if(C<256)t.write(C);else{if(256===C)break;for(U=LENGTH_EXTRA_BIT_BASE[D=C-257],0<(S=LENGTH_EXTRA_BIT_LEN[D])&&(U+=e.readRange(S)),m=void 0,F=P,O=e.readRangeCoded(P);void 0===(m=R[F][O]);){if(b<=F)throw new Error("Data is corrupted");F++,O<<=1,O|=e.read()}x=DISTANCE_EXTRA_BIT_BASE[m],0<(y=DISTANCE_EXTRA_BIT_LEN[m])&&(x+=e.readRange(y)),X=t.index-x;for(let e=0;e<U;e++)t.write(t.buffer[X+e])}}}function inflate$1(e){const t=new BitReadStream(e);if(8!==t.readRange(4))throw new Error("Not compressed by deflate");t.readRange(4),t.readRange(5),t.readRange(1),t.readRange(2);return inflate(e,2)}function deflate$1(e){const t=deflate(e),n=new BitWriteStream(new Uint8Array(1));n.writeRange(8,4),n.writeRange(7,4);const r=new BitWriteStream(new Uint8Array(1));r.writeRange(28,5),r.writeRange(0,1),r.writeRange(2,2);const i=new BitWriteStream(new Uint8Array(4)),a=calcAdler32(e);i.writeRange(a>>>24,8),i.writeRange(a>>>16&255,8),i.writeRange(a>>>8&255,8),i.writeRange(255&a,8);const o=new Uint8Array(t.length+6);return o.set(n.buffer),o.set(r.buffer,1),o.set(t,2),o.set(i.buffer,o.length-4),o}function calcCrc32(e,t=0,n){n||(n=e.length);let r=-1;for(let i=t;i<n;i++)r=crc32table[255&(r^e[i])]^r>>>8;return-1^r}const crc32table=new Uint32Array(256);for(let e=0;e<256;e++){let t=e;for(let e=0;e<8;e++)1&t?t=3988292384^t>>>1:t>>>=1;crc32table[e]=t}function startsWith(e,t,n=0){const r=n,i=t.length;for(let n=0;n<i;n++)if(e[n+r]!==t[n])return!1;return!0}function copy(e,t,n,r,i){for(let a=0;a<i;a++)n[r+a]=e[t+a]}function readString(e,t,n){let r="";for(let i=0;i<n;i++)r+=String.fromCharCode(e[i+t]);return r}function convertCodes(e){const t=e.length,n=new Uint8Array(t);for(let r=0;r<t;r++)n[r]=e.charCodeAt(r);return n}function readUint8(e,t){return e[t]}function readUInt32BE(e,t){return 16777216*e[t]+(e[t+1]<<16|e[t+2]<<8|e[t+3])}function writeUInt8(e,t,n){t[n]=e}function writeUInt32BE(e,t,n){t[n]=e>>>24,t[n+1]=e>>>16,t[n+2]=e>>>8,t[n+3]=255&e}function readBits(e,t,n){const r=t%8,i=255&255>>>r;return(e[t/8|0]&i)>>>8-r-n}const SIGNATURE=new Uint8Array([137,80,78,71,13,10,26,10]);function parseChunk(e){if(!startsWith(e,SIGNATURE,0))throw new Error("Not PNG");let t=SIGNATURE.length;const n=new Map,r=e.length;for(;t<r;){const r=readChunk(e,t);if(t+=r.data.length+12,"IDAT"===r.type&&n.has("IDAT")){const e=n.get("IDAT"),t=new Uint8Array(e.data.length+r.data.length);t.set(e.data),t.set(r.data,e.data.length),n.set("IDAT",{type:"IDAT",data:t})}else n.set(r.type,r);if("IEND"===r.type)break}return n}function packChunk(e){let t=8;e.forEach(e=>{t+=e.data.length,t+=12});const n=new Uint8Array(t);let r=0;return copy(SIGNATURE,0,n,r,SIGNATURE.length),r+=SIGNATURE.length,e.forEach(e=>{writeUInt32BE(e.data.length,n,r),r+=4;const t=convertCodes(e.type);copy(t,0,n,r,t.length),r+=4,copy(e.data,0,n,r,e.data.length),r+=e.data.length,writeUInt32BE(calcCrc32(n,r-4-e.data.length,r),n,r),r+=4}),n}function readChunk(e,t){const n=readUInt32BE(e,t);return{type:readString(e,t+4,4),data:e.slice(t+8,t+8+n)}}const FILTER_TYPE=Object.freeze({NONE:0,SUB:1,UP:2,AVERAGE:3,PAETH:4}),COLOR_TYPE=Object.freeze({GRAY:0,RGB:2,INDEX:3,GRAY_ALPHA:4,RGBA:6});function inflateFilter(e,t,n,r,i,a,o){const s=calcPixelPropsLen(i),l=s*t,f=s*r*t,E=calcPixelByte(i,r),c=E*t,h=new Uint8Array(t*n*E);let d=0,u=0,_=0,T=0,w=0;for(let t=0;t<n;++t){const t=readBits(e,d,8);if(d+=8,FILTER_TYPE.NONE===t)for(let t=0;t<l;++t){const n=readBits(e,d+t*r,r);void 0!==a&&i===COLOR_TYPE.INDEX?(copy(a,3*n,h,u+4*t,3),void 0!==o&&void 0!==o[n]?h[u+4*t+3]=o[n]:h[u+4*t+3]=255):h[u+t]=n}else if(FILTER_TYPE.SUB===t)for(let t=0;t<l;++t)h[u+t]=t<s?readBits(e,d+t*r,r):(h[u+t-s]+readBits(e,d+t*r,r))%256;else if(FILTER_TYPE.UP===t)for(let t=0;t<l;t++)h[u+t]=u<l?readBits(e,d+t*r,r):(h[u+t-l]+readBits(e,d+t*r,r))%256;else if(FILTER_TYPE.AVERAGE===t)for(let t=0;t<l;t++)_=T=0,t>=s&&(_=h[u+t-s]),u>=l&&(T=h[u+t-l]),h[u+t]=((_+T)/2+readBits(e,d+t*r,r))%256;else{if(FILTER_TYPE.PAETH!==t)throw new Error("Unknown filter");for(let t=0;t<l;t++)_=T=w=0,t>=s&&u>=l?(_=h[u+t-s],T=h[u+t-l],w=h[u+t-s-l]):t>=s?_=h[u+t-s]:u>=l&&(T=h[u+t-l]),h[u+t]=(calcPaeth(_,T,w)+readBits(e,d+t*r,r))%256}d+=f%8==0?f:f+(8-f%8),u+=c}return h}function deflateFilter(e,t,n,r,i){const a=calcPixelByte(i,r),o=a*t,s=new Uint8Array(t*n*a+n);let l=0,f=0,E=0,c=0,h=0;for(let t=0;t<n;t++){let t=FILTER_TYPE.NONE,n=calcExpectedValueNone(e,f,o),r=calcExpectedValueSub(e,f,o);if(n>r&&(n=r,t=FILTER_TYPE.SUB),n>(r=calcExpectedValueUp(e,f,o))&&(n=r,t=FILTER_TYPE.UP),n>(r=calcExpectedValueAverage(e,f,o,a))&&(n=r,t=FILTER_TYPE.AVERAGE),n>(r=calcExpectedValuePaeth(e,f,o,a))&&(n=r,t=FILTER_TYPE.PAETH),s[l]=t,l++,FILTER_TYPE.NONE===t)for(let t=0;t<o;t++)s[l+t]=e[f+t];else if(FILTER_TYPE.SUB===t)for(let t=0;t<o;t++)s[l+t]=t<a?e[f+t]:e[f+t]-e[f+t-a];else if(FILTER_TYPE.UP===t)for(let t=0;t<o;t++)s[l+t]=l<o?e[f+t]:e[f+t]-e[f+t-o];else if(FILTER_TYPE.AVERAGE===t)for(let t=0;t<o;t++)E=c=0,t>=a&&(E=e[f+t-a]),l>=o&&(c=e[f+t-o]),s[l+t]=e[f+t]-((E+c)/2|0);else if(FILTER_TYPE.PAETH===t)for(let t=0;t<o;t++)E=c=h=0,t>=a&&l>=o?(E=e[f+t-a],c=e[f+t-o],h=e[f+t-a-o]):t>=a?E=e[f+t-a]:l>=o&&(c=e[f+t-o]),s[l+t]=e[f+t]-calcPaeth(E,c,h);l+=o,f+=o}return s}function calcPixelPropsLen(e){let t=0;if(COLOR_TYPE.GRAY===e)t=1;else if(COLOR_TYPE.RGB===e)t=3;else if(COLOR_TYPE.INDEX===e)t=1;else if(COLOR_TYPE.GRAY_ALPHA===e)t=2;else{if(COLOR_TYPE.RGBA!==e)throw new Error("Unknown colorType");t=4}return t}function calcPixelByte(e,t){let n=0;if(COLOR_TYPE.GRAY===e)n=t/8;else if(COLOR_TYPE.RGB===e)n=t/8*3;else if(COLOR_TYPE.INDEX===e)n=4;else if(COLOR_TYPE.GRAY_ALPHA===e)n=t/8*2;else{if(COLOR_TYPE.RGBA!==e)throw new Error("Unknown colorType");n=t/8*4}return n}function calcPaeth(e,t,n){const r=e+t-n,i=Math.abs(r-e),a=Math.abs(r-t),o=Math.abs(r-n);return i<=a&&i<=o?e:a<=o?t:n}function calcExpectedValueNone(e,t,n){let r=0;for(let i=t,a=t+n;i<a;i++)r+=e[i];return r}function calcExpectedValueSub(e,t,n){let r=0,i=0;for(let a=t,o=t+n;a<o;a++)r+=a<n?e[a]:0<=(i=e[a]-e[a-n])?i:i+256;return r}function calcExpectedValueUp(e,t,n){let r=0,i=0;for(let a=t,o=t+n;a<o;a++)r+=a<n?e[a]:0<=(i=e[a]-e[a-n])?i:i+256;return r}function calcExpectedValueAverage(e,t,n,r){let i=0,a=0,o=0,s=0;for(let l=t,f=t+n;l<f;l++)o=s=0,l>=r&&(o=e[l-r]),l>=n&&(s=e[l-n]),i+=0<=(a=e[l]-((o+s)/2|0))?a:a+256;return i}function calcExpectedValuePaeth(e,t,n,r){let i=0,a=0,o=0,s=0,l=0;for(let f=t,E=t+n;f<E;f++)o=s=l=0,f>=r&&t>=n?(o=e[f-r],s=e[f-n],l=e[f-n-r]):f>=r?o=e[f-r]:f>=n&&(s=e[f-n]),i+=0<=(a=e[f]-calcPaeth(o,s,l))?a:a+256;return i}
/**
 * @license Copyright (c) 2018 zprodev
 * https://github.com/zprodev/png.es
 */class PNG{constructor(e,t,n=6,r=8){if(this._pixelPropsNum=0,n===COLOR_TYPE.INDEX)throw new Error("Not support IndexedColor");this._width=e,this._height=t,this._colorType=n,this._bitDepth=r,this._pixelPropsNum=calcPixelPropsLen(n);const i=calcPixelByte(n,r);this._data=new Uint8Array(e*t*i)}get data(){return this._data}get width(){return this._width}get height(){return this._height}get colorType(){return this._colorType}get bitDepth(){return this._bitDepth}get pixelLength(){return this._pixelPropsNum}setData(e){if(this._data.length!==e.length)throw new Error("Data size does not match");const t=this._data.length;for(let n=0;n<t;n++)this._data[n]=e[n]}getPixel(e,t){const n=[],r=(e-1+this._width*(t-1))*this._pixelPropsNum,i=this._data;for(let e=r,t=r+this._pixelPropsNum;e<t;e++)n.push(i[e]);return n}setPixel(e,t,n){if(n.length!==this._pixelPropsNum)throw new Error("Don't match pixelData size");const r=(e-1+this._width*(t-1))*this._pixelPropsNum,i=this._data;for(let e=0;e<this._pixelPropsNum;e++)i[e+r]=n[e]}}function parse(e,t){const n=parseChunk(e),r=n.get("IHDR"),i=readUInt32BE(r.data,0),a=readUInt32BE(r.data,4),o=readUint8(r.data,8),s=readUint8(r.data,9),l=readUint8(r.data,10),f=readUint8(r.data,11),E=readUint8(r.data,12);if(0!==l)throw new Error("Unknown compression");if(0!==f)throw new Error("Unknown filter");if(0!==E)throw new Error("Interlace does not support");const c=n.get("IDAT"),h=n.has("PLTE")?n.get("PLTE").data:void 0,d=n.has("tRNS")?n.get("tRNS").data:void 0,u=inflateFilter(t&&t.inflate?t.inflate(c.data):inflate$1(c.data),i,a,o,s,h,d);if(s===COLOR_TYPE.INDEX){const e=new PNG(i,a);return e.setData(u),e}{const e=new PNG(i,a,s,o);return e.setData(u),e}}function pack(e,t){const n=new Map,r=new Uint8Array(13);writeUInt32BE(e.width,r,0),writeUInt32BE(e.height,r,4),writeUInt8(e.bitDepth,r,8),writeUInt8(e.colorType,r,9),n.set("IHDR",{type:"IHDR",data:r});const i=deflateFilter(e.data,e.width,e.height,e.bitDepth,e.colorType),a=t&&t.deflate?t.deflate(i):deflate$1(i);return n.set("IDAT",{type:"IDAT",data:a}),n.set("IEND",{type:"IEND",data:new Uint8Array(0)}),packChunk(n)}export{PNG,parse,pack,COLOR_TYPE};