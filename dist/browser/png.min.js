var pnges=function(t){"use strict";const e=Object.freeze({UNCOMPRESSED:0,FIXED:1,DYNAMIC:2}),n=131072,r=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],o=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258],i=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577],s=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],a=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];function f(t){const e=Object.keys(t);let n=0,r=0,o=Number.MAX_SAFE_INTEGER;e.forEach(t=>{n=Number(t),r<n&&(r=n),o>n&&(o=n)});let i,s=0;const a={};for(let e=o;e<=r;e++){void 0===(i=t[e])&&(i=[]),i.sort((t,e)=>t<e?-1:t>e?1:0);const n={};i.forEach(t=>{n[s]=t,s++}),a[e]=n,s<<=1}return a}function h(t,e=15){const n={};for(const e of t)n[e]?n[e]++:n[e]=1;const r=Object.keys(n);let o=[],i=0,s=[];if(1===r.length)s.push({count:n[0],simbles:[Number(r[0])]});else for(let t=0;t<e;t++){for(s=[],r.forEach(t=>{const e={count:n[Number(t)],simbles:[Number(t)]};s.push(e)}),i=0;i+2<=o.length;){const t={count:o[i].count+o[i+1].count,simbles:o[i].simbles.concat(o[i+1].simbles)};s.push(t),i+=2}(s=s.sort((t,e)=>t.count<e.count?-1:t.count>e.count?1:0)).length%2!=0&&s.pop(),o=s}const a={};let f;s.forEach(t=>{t.simbles.forEach(t=>{a[t]?a[t]++:a[t]=1})});const h=Object.keys(a),l={};let c=0,d=3,u=Number.MAX_SAFE_INTEGER,w=0;h.forEach(t=>{d=a[Number(t)],l[d]||(l[d]=[],u>d&&(u=d),w<d&&(w=d)),l[d].push(Number(t))}),c=0;const g=new Map;for(let t=u;t<=w;t++)(f=l[t])&&(f=f.sort((t,e)=>t<e?-1:t>e?1:0)).forEach(e=>{g.set(e,{code:c,bitlen:t}),c++}),c<<=1;return g}const l=3,c=128,d=16,u=8;function w(t,e,n){let r=e;const s=e+n-l;let a=0,f=0,h=0,w=0,g=0,b=0,E=0;const p=[],R={},A={},I=function(t,e,n){const r=e+n-l,o={};for(let n=e;n<=r;n++){const e=t[n]<<16|t[n+1]<<8|t[n+2];void 0===o[e]&&(o[e]=[]),o[e].push(n)}return o}(t,e,n);for(;r<=s;){const e=t[r]<<16|t[r+1]<<8|t[r+2],n=I[e];if(void 0===n||n.length<=1){p.push([t[r]]),r++;continue}a=r>32768?r-32768:0,h=0,w=0;let l=R[e]||0;for(;n[l]<a;)l=l+1|0;for(R[e]=l,l=A[e]||0;n[l]<r;)l=l+1|0;A[e]=l;let y=0;t:for(let o=A[e]-1,i=R[e];i<=o&&!(y>=c||h>=u&&y>=d);o--){y++;const e=n[o];for(let n=h-1;0<n;n--)if(t[e+n]!==t[r+n])continue t;f=258;for(let n=h;n<=258;n++)if(t[e+n]!==t[r+n]){f=n;break}if(h<f&&(h=f,w=e,258<=f))break}if(h>=3&&r+h<=s){g=r-w;for(let t=0;t<o.length&&!(o[t]>h);t++)b=t;for(let t=0;t<i.length&&!(i[t]>g);t++)E=t;p.push([b,E,h,g]),r+=h}else p.push([t[r]]),r++}return p.push([t[r]]),p.push([t[r+1]]),p}class g{constructor(t,e=0,n=0){this.nowBitsIndex=0,this.isEnd=!1,this.buffer=t,this.bufferIndex=e,this.nowBits=t[e],this.nowBitsIndex=n}write(t){if(this.isEnd)throw new Error("Lack of data length");t<<=this.nowBitsIndex,this.nowBits+=t,this.nowBitsIndex++,this.nowBitsIndex>=8&&(this.buffer[this.bufferIndex]=this.nowBits,this.bufferIndex++,this.nowBits=0,this.nowBitsIndex=0,this.buffer.length<=this.bufferIndex&&(this.isEnd=!0))}writeRange(t,e){let n=1,r=0;for(let o=0;o<e;o++)r=t&n?1:0,this.write(r),n<<=1}writeRangeCoded(t,e){let n=1<<e-1,r=0;for(let o=0;o<e;o++)r=t&n?1:0,this.write(r),n>>>=1}}function b(t,e,n,f){const l=w(e,n,f),c=[256],d=[];let u=256,g=0;for(let t=0,e=l.length;t<e;t++){const e=l[t];let n=e[0];const r=e[1];void 0!==r&&(n+=257,d.push(r),g<r&&(g=r)),c.push(n),u<n&&(u=n)}const b=h(c),E=h(d),p=[];for(let t=0;t<=u;t++)b.has(t)?p.push(b.get(t).bitlen):p.push(0);const R=p.length;for(let t=0;t<=g;t++)E.has(t)?p.push(E.get(t).bitlen):p.push(0);const A=p.length-R,I=[],y=[];let N=0,D=0;for(let t=0;t<p.length;t++){for(N=p[t],D=1;N===p[t+1];)if(D++,t++,0===N){if(138<=D)break}else if(6<=D)break;if(4<=D)0===N?11<=D?I.push(18):I.push(17):(I.push(N),y.push(1),D--,I.push(16)),y.push(D);else for(let t=0;t<D;t++)I.push(N),y.push(1)}const B=h(I,7);let _,x=0;a.forEach((t,e)=>{B.has(t)&&(x=e+1)}),t.writeRange(R-257,5),t.writeRange(A-1,5),t.writeRange(x-4,4);for(let e=0;e<x;e++)void 0!==(_=B.get(a[e]))?t.writeRange(_.bitlen,3):t.writeRange(0,3);I.forEach((e,n)=>{if(void 0===(_=B.get(e)))throw new Error("Data is corrupted");t.writeRangeCoded(_.code,_.bitlen),18===e?t.writeRange(y[n]-11,7):17===e?t.writeRange(y[n]-3,3):16===e&&t.writeRange(y[n]-3,2)});for(let e=0,n=l.length;e<n;e++){const n=l[e],a=n[0],f=n[1];if(void 0!==f){if(void 0===(_=b.get(a+257)))throw new Error("Data is corrupted");t.writeRangeCoded(_.code,_.bitlen),0<r[a]&&(D=n[2],t.writeRange(D-o[a],r[a]));const e=E.get(f);if(void 0===e)throw new Error("Data is corrupted");if(t.writeRangeCoded(e.code,e.bitlen),0<s[f]){const e=n[3];t.writeRange(e-i[f],s[f])}}else{if(void 0===(_=b.get(a)))throw new Error("Data is corrupted");t.writeRangeCoded(_.code,_.bitlen)}}if(void 0===(_=b.get(256)))throw new Error("Data is corrupted");t.writeRangeCoded(_.code,_.bitlen)}class E{constructor(t,e=0){this.nowBitsLength=0,this.isEnd=!1,this.buffer=t,this.bufferIndex=e,this.nowBits=t[e],this.nowBitsLength=8}read(){if(this.isEnd)throw new Error("Lack of data length");const t=1&this.nowBits;return this.nowBitsLength>1?(this.nowBitsLength--,this.nowBits>>=1):(this.bufferIndex++,this.bufferIndex<this.buffer.length?(this.nowBits=this.buffer[this.bufferIndex],this.nowBitsLength=8):(this.nowBitsLength=0,this.isEnd=!0)),t}readRange(t){for(;this.nowBitsLength<=t;)this.nowBits|=this.buffer[++this.bufferIndex]<<this.nowBitsLength,this.nowBitsLength+=8;const e=this.nowBits&(1<<t)-1;return this.nowBits>>>=t,this.nowBitsLength-=t,e}readRangeCoded(t){let e=0;for(let n=0;n<t;n++)e<<=1,e|=this.read();return e}}class p{constructor(t){this.index=0,this.buffer=new Uint8Array(t),this.length=t,this._extendedSize=t}write(t){if(this.length<=this.index){this.length+=this._extendedSize;const t=new Uint8Array(this.length),e=this.buffer.length;for(let n=0;n<e;n++)t[n]=this.buffer[n];this.buffer=t}this.buffer[this.index]=t,this.index++}}const R=f(function(){const t={7:[],8:[],9:[]};for(let e=0;e<=287;e++)e<=143?t[8].push(e):e<=255?t[9].push(e):e<=279?t[7].push(e):t[8].push(e);return t}());function A(t,e){t.nowBitsLength<8&&t.readRange(t.nowBitsLength);const n=t.readRange(8)|t.readRange(8)<<8;if(n+(t.readRange(8)|t.readRange(8)<<8)!==65535)throw new Error("Data is corrupted");for(let r=0;r<n;r++)e.write(t.readRange(8))}function I(t,e){const n=R,a=Object.keys(n);let f=0,h=0,l=Number.MAX_SAFE_INTEGER;a.forEach(t=>{f=Number(t),h<f&&(h=f),l>f&&(l=f)});let c,d,u,w,g,b,E,p,A=0;for(;!t.isEnd;){for(c=void 0,f=l,A=t.readRangeCoded(l);void 0===(c=n[f][A]);){if(h<=f)throw new Error("Data is corrupted");f++,A<<=1,A|=t.read()}if(c<256)e.write(c);else{if(256===c)break;u=o[d=c-257],0<(w=r[d])&&(u+=t.readRange(w)),g=t.readRangeCoded(5),b=i[g],0<(E=s[g])&&(b+=t.readRange(E)),p=e.index-b;for(let t=0;t<u;t++)e.write(e.buffer[p+t])}}}function y(t,e){const n=t.readRange(5)+257,h=t.readRange(5)+1,l=t.readRange(4)+4;let c=0;const d={};for(let e=0;e<l;e++)0!==(c=t.readRange(3))&&(d[c]||(d[c]=[]),d[c].push(a[e]));const u=f(d),w=Object.keys(u);let g=0,b=Number.MAX_SAFE_INTEGER;w.forEach(t=>{c=Number(t),g<c&&(g=c),b>c&&(b=c)});const E={},p={};let R,A=0,I=0,y=0;const N=n+h;for(let e=0;e<N;){for(R=void 0,c=b,A=t.readRangeCoded(b);void 0===(R=u[c][A]);){if(g<=c)throw new Error("Data is corrupted");c++,A<<=1,A|=t.read()}if(16===R?I=3+t.readRange(2):17===R?(I=3+t.readRange(3),y=0):18===R?(I=11+t.readRange(7),y=0):(I=1,y=R),y<=0)e+=I;else for(;I;)e<n?(E[y]||(E[y]=[]),E[y].push(e++)):(p[y]||(p[y]=[]),p[y].push(e++-n)),I--}const D=f(E),B=f(p),_=Object.keys(D);let x=0,U=0,m=Number.MAX_SAFE_INTEGER;_.forEach(t=>{x=Number(t),U<x&&(U=x),m>x&&(m=x)});const T=Object.keys(B);let v=0,k=0,C=Number.MAX_SAFE_INTEGER;T.forEach(t=>{v=Number(t),k<v&&(k=v),C>v&&(C=v)});let M,S,O,P,L,G,j,F,X,H,z=0;for(;!t.isEnd;){for(M=void 0,x=m,z=t.readRangeCoded(m);void 0===(M=D[x][z]);){if(U<=x)throw new Error("Data is corrupted");x++,z<<=1,z|=t.read()}if(M<256)e.write(M);else{if(256===M)break;for(O=o[S=M-257],0<(P=r[S])&&(O+=t.readRange(P)),L=void 0,F=C,X=t.readRangeCoded(C);void 0===(L=B[F][X]);){if(k<=F)throw new Error("Data is corrupted");F++,X<<=1,X|=t.read()}G=i[L],0<(j=s[L])&&(G+=t.readRange(j)),H=e.index-G;for(let t=0;t<O;t++)e.write(e.buffer[H+t])}}}function N(t){const n=new E(t);if(8!==n.readRange(4))throw new Error("Not compressed by deflate");n.readRange(4),n.readRange(5),n.readRange(1),n.readRange(2);return function(t,n=0){const r=new p(10*t.length),o=new E(t,n);let i=0,s=0;for(;1!==i;){if(i=o.readRange(1),(s=o.readRange(2))===e.UNCOMPRESSED)A(o,r);else if(s===e.FIXED)I(o,r);else{if(s!==e.DYNAMIC)throw new Error("Not supported BTYPE : "+s);y(o,r)}if(0===i&&o.isEnd)throw new Error("Data length is insufficient")}return r.buffer.subarray(0,r.index)}(t,2)}function D(t){const r=function(t){const r=t.length,o=new g(new Uint8Array(r<n/2?n:2*r));let i=0,s=0;for(;i+n>=r?(s=r-i,o.writeRange(1,1)):(s=n,o.writeRange(0,1)),o.writeRange(e.DYNAMIC,2),b(o,t,i,s),!((i+=n)>=r););return 0!==o.nowBitsIndex&&o.writeRange(0,8-o.nowBitsIndex),o.buffer.subarray(0,o.bufferIndex)}(t),o=new g(new Uint8Array(1));o.writeRange(8,4),o.writeRange(7,4);const i=new g(new Uint8Array(1));i.writeRange(28,5),i.writeRange(0,1),i.writeRange(2,2);const s=new g(new Uint8Array(4)),a=function(t){let e=1,n=0;const r=t.length;for(let o=0;o<r;o++)n=((e=(e+t[o])%65521)+n)%65521;return(n<<16)+e}(t);s.writeRange(a>>>24,8),s.writeRange(a>>>16&255,8),s.writeRange(a>>>8&255,8),s.writeRange(255&a,8);const f=new Uint8Array(r.length+6);return f.set(o.buffer),f.set(i.buffer,1),f.set(r,2),f.set(s.buffer,f.length-4),f}const B=new Uint32Array(256);for(let t=0;t<256;t++){let e=t;for(let t=0;t<8;t++)1&e?e=3988292384^e>>>1:e>>>=1;B[t]=e}function _(t,e,n=0){const r=t.length;for(let o=0;o<r;o++)e[n+o]=t[o]}function x(t,e){return t[e]}function U(t,e){return 16777216*t[e]+(t[e+1]<<16|t[e+2]<<8|t[e+3])}function m(t,e,n){e[n]=t}function T(t,e,n){e[n]=t>>>24,e[n+1]=t>>>16,e[n+2]=t>>>8,e[n+3]=255&t}const v=new Uint8Array([137,80,78,71,13,10,26,10]);function k(t){let e=8;t.forEach(t=>{e+=t.data.length,e+=12});const n=new Uint8Array(e);let r=0;return _(v,n,r),r+=v.length,t.forEach(t=>{T(t.data.length,n,r),r+=4,_(function(t){const e=t.length,n=new Uint8Array(e);for(let r=0;r<e;r++)n[r]=t.charCodeAt(r);return n}(t.type),n,r),r+=4,_(t.data,n,r),r+=t.data.length,T(function(t,e=0,n){n||(n=t.length);let r=-1;for(let o=e;o<n;o++)r=B[255&(r^t[o])]^r>>>8;return-1^r}(n,r-4-t.data.length,r),n,r),r+=4}),n}function C(t,e){const n=U(t,e);return{type:function(t,e,n){let r="";for(let o=0;o<n;o++)r+=String.fromCharCode(t[o+e]);return r}(t,e+4,4),data:t.slice(e+8,e+8+n)}}const M=Object.freeze({NONE:0,SUB:1,UP:2,AVERAGE:3,PAETH:4});function S(t,e){let n=0;if(0===t)n=e/8;else if(2===t)n=e/8*3;else{if(3===t)throw new Error("IndexColor does not support");if(4===t)n=e/8*2;else{if(6!==t)throw new Error("Unknown colorType");n=e/8*4}}return n}function O(t,e,n){const r=t+e-n,o=Math.abs(r-t),i=Math.abs(r-e),s=Math.abs(r-n);return o<=i&&o<=s?t:i<=s?e:n}function P(t,e,n){let r=0;for(let o=e,i=e+n;o<i;o++)r+=t[o];return r}function L(t,e,n){let r=0,o=0;for(let i=e,s=e+n;i<s;i++)r+=i<n?t[i]:0<=(o=t[i]-t[i-n])?o:o+256;return r}function G(t,e,n){let r=0,o=0;for(let i=e,s=e+n;i<s;i++)r+=i<n?t[i]:0<=(o=t[i]-t[i-n])?o:o+256;return r}function j(t,e,n,r){let o=0,i=0,s=0,a=0;for(let f=e,h=e+n;f<h;f++)s=a=0,f>=r&&(s=t[f-r]),f>=n&&(a=t[f-n]),o+=0<=(i=t[f]-((s+a)/2|0))?i:i+256;return o}function F(t,e,n,r){let o=0,i=0,s=0,a=0,f=0;for(let h=e,l=e+n;h<l;h++)s=a=f=0,h>=r&&e>=n?(s=t[h-r],a=t[h-n],f=t[h-n-r]):h>=r?s=t[h-r]:h>=n&&(a=t[h-n]),o+=0<=(i=t[h]-O(s,a,f))?i:i+256;return o}class X{constructor(t,e,n=6,r=8){this._width=t,this._height=e,this._colorType=n,this._bitDepth=r;const o=S(n,r);this._data=new Uint8Array(t*e*o)}get data(){return this._data}get width(){return this._width}get height(){return this._height}get colorType(){return this._colorType}get bitDepth(){return this._bitDepth}setData(t){if(this._data.length!==t.length)throw new Error("Data size does not match");const e=this._data.length;for(let n=0;n<e;n++)this._data[n]=t[n]}getPixel(t,e){const n=4*(t+this._width*e),r=this._data;return{r:r[n],g:r[n+1],b:r[n+2],a:r[n+3]}}setPixel(t,e,n){const r=4*(t+this._width*e),o=this._data;void 0!==n.r&&(o[r]=n.r),void 0!==n.g&&(o[r+1]=n.g),void 0!==n.b&&(o[r+2]=n.b),void 0!==n.a&&(o[r+3]=n.a)}}return t.PNG=X,t.parse=function(t,e){const n=function(t){if(!function(t,e,n=0){const r=n,o=e.length;for(let n=0;n<o;n++)if(t[n+r]!==e[n])return!1;return!0}(t,v,0))throw new Error("Not PNG");let e=v.length;const n=new Map,r=t.length;for(;e<r;){const r=C(t,e);if(e+=r.data.length+12,"IDAT"===r.type&&n.has("IDAT")){const t=n.get("IDAT"),e=new Uint8Array(t.data.length+r.data.length);e.set(t.data),e.set(r.data,t.data.length),n.set("IDAT",{type:"IDAT",data:e})}else n.set(r.type,r);if("IEND"===r.type)break}return n}(t),r=n.get("IHDR"),o=U(r.data,0),i=U(r.data,4),s=x(r.data,8),a=x(r.data,9),f=x(r.data,10),h=x(r.data,11),l=x(r.data,12);if(0!==f)throw new Error("Unknown compression");if(0!==h)throw new Error("Unknown filter");if(0!==l)throw new Error("Interlace does not support");const c=n.get("IDAT"),d=function(t,e,n,r,o){if(8!==r)throw new Error("Only bit depth 8 is supported");const i=S(o,r),s=i*e,a=new Uint8Array(e*n*i);let f=0,h=0,l=0,c=0,d=0;for(let e=0;e<n;e++){const e=x(t,f);if(f++,M.NONE===e)for(let e=0;e<s;e++)a[h+e]=t[f+e];else if(M.SUB===e)for(let e=0;e<s;e++)a[h+e]=e<i?t[f+e]:(a[h+e-i]+t[f+e])%256;else if(M.UP===e)for(let e=0;e<s;e++)a[h+e]=h<s?t[f+e]:(a[h+e-s]+t[f+e])%256;else if(M.AVERAGE===e)for(let e=0;e<s;e++)l=c=0,e>=i&&(l=a[h+e-i]),h>=s&&(c=a[h+e-s]),a[h+e]=((l+c)/2+t[f+e])%256;else{if(M.PAETH!==e)throw new Error("Unknown filter");for(let e=0;e<s;e++)l=c=d=0,e>=i&&h>=s?(l=a[h+e-i],c=a[h+e-s],d=a[h+e-s-i]):e>=i?l=a[h+e-i]:h>=s&&(c=a[h+e-s]),a[h+e]=(O(l,c,d)+t[f+e])%256}f+=s,h+=s}return a}(e&&e.inflate?e.inflate(c.data):N(c.data),o,i,s,a),u=new X(o,i,a,s);return u.setData(d),u},t.pack=function(t,e){const n=new Map,r=new Uint8Array(13);T(t.width,r,0),T(t.height,r,4),m(t.bitDepth,r,8),m(t.colorType,r,9),n.set("IHDR",{type:"IHDR",data:r});const o=function(t,e,n,r,o){const i=S(o,r),s=i*e,a=new Uint8Array(e*n*i+n);let f=0,h=0,l=0,c=0,d=0;for(let e=0;e<n;e++){let e=M.NONE,n=P(t,h,s),r=L(t,h,s);if(n>r&&(n=r,e=M.SUB),n>(r=G(t,h,s))&&(n=r,e=M.UP),n>(r=j(t,h,s,i))&&(n=r,e=M.AVERAGE),n>(r=F(t,h,s,i))&&(n=r,e=M.PAETH),a[f]=e,f++,M.NONE===e)for(let e=0;e<s;e++)a[f+e]=t[h+e];else if(M.SUB===e)for(let e=0;e<s;e++)a[f+e]=e<i?t[h+e]:t[h+e]-t[h+e-i];else if(M.UP===e)for(let e=0;e<s;e++)a[f+e]=f<s?t[h+e]:t[h+e]-t[h+e-s];else if(M.AVERAGE===e)for(let e=0;e<s;e++)l=c=0,e>=i&&(l=t[h+e-i]),h>=s&&(c=t[h+e-s]),a[f+e]=t[h+e]-((l+c)/2|0);else if(M.PAETH===e)for(let e=0;e<s;e++)l=c=d=0,e>=i&&h>=s?(l=t[h+e-i],c=t[h+e-s],d=t[h+e-s-i]):e>=i?l=t[h+e-i]:h>=s&&(c=t[h+e-s]),a[f+e]=t[h+e]-O(l,c,d);f+=s,h+=s}return a}(t.data,t.width,t.height,t.bitDepth,t.colorType),i=e&&e.deflate?e.deflate(o):D(o);return n.set("IDAT",{type:"IDAT",data:i}),k(n)},t}({});